<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Jackie Hu Space</title>
    <link>http://sleephu.github.io/tags/java/</link>
    <description>Recent content in Java on Jackie Hu Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright &amp;#169; by Jackie Hu</copyright>
    <lastBuildDate>Thu, 07 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://sleephu.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SCJP Reading Notes - 2</title>
      <link>http://sleephu.github.io/post/04-07-16/</link>
      <pubDate>Thu, 07 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sleephu.github.io/post/04-07-16/</guid>
      <description>&lt;p&gt;Summary
It is reading notes about the book &amp;ndash; SCJP.&lt;/p&gt;

&lt;p&gt;Object Oriented&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Key Characteristics&lt;/p&gt;

&lt;p&gt;a. Encapsulation: associate with hiding implementation details, the ability to make changes in your implementation without breaking the code of others who use your code&lt;/p&gt;

&lt;p&gt;b. Inheritance: used to promote code reuse; use polymophism (many forms)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i. IS-A: extends/implements
ii. HAS-A: based on usage, not inheritance
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c. Polymorphism: many forms (see eg. as follows)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dog extend Animal implements Animatable {}
Dog is:
     i. An Object
     ii. An Animal
     iii. A Dog
     iv. An Animatable
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Overriding v.s Overloading&lt;/p&gt;

&lt;p&gt;a. Overriding: if A extends B, A has the opportunity to override method in B (except final); Overloading: name reuse&lt;/p&gt;

&lt;p&gt;b. Overriding cannot change argument list; Overloading must change argument&lt;/p&gt;

&lt;p&gt;c. The overriding method can throw any unchecked (runtime) exception, regardless of whether the overriden method declare the exception, but can only throw fewer or narrower exceptions; the overloading can declare new or broader checked exceptions&lt;/p&gt;

&lt;p&gt;d. The return type must be the same as or a subtype of the return type declared in the original overriden superclass, while overloading method can change the return type&lt;/p&gt;

&lt;p&gt;e. The overriding method cannot have more restrict access modifier than original overriden method in superclass, while overloading method could have any access modifier&lt;/p&gt;

&lt;p&gt;f. The reference type (not the object type) determines which overloaded method is invoked, while the object type determines which overriden method is invoked!!!(important)&lt;/p&gt;

&lt;p&gt;eg:
     Overloading:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; class Animal {}
 class Horse extends Animal {}
 class UseAnimal {
     public void doStuff(Animal a) {
        System.out.println(&amp;quot;Animal Version&amp;quot;);
     }
     public void doStuff() {
        System.out.println(&amp;quot;Horse Version&amp;quot;);
 }
   } 
 UseAnimal ua = new UseAnimal();
 Animal a = new Horse();
 ua.doStuff(a); // output is &amp;quot;Animal Version&amp;quot;
 ---------------------------------------------------------
 Overriding:
 suppose eat() in Animal prints out &amp;quot;Animal eat&amp;quot;, in Horse prints out &amp;quot;Horse eat&amp;quot;
 Animal a = new Horse();
 System.out.println(a.eat()); //output: &amp;quot;Horse eat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explian: compiler checks the reference type which is Animal, but it&amp;rsquo;s JVM which looks for the object type decides which version to be invoked&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Casting
 a. downcast: casting down the inheritance tree to a more specific class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (animal instanceof Dog) {
   Dog d = (Dog)animal;
   d.playDead();
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. upcast: works implicitly&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dog d = new Dog();
Animal a1 = d; //upcast ok with no explicit cast
Animal a2 = (Animal)d; //upcast ok with an explicit cast
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Interface&lt;/p&gt;

&lt;p&gt;abstract class can choose to implement any, all, or none of methods from any of the interface&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Constructor:&lt;/p&gt;

&lt;p&gt;a. Every class has constructor (abstract class&amp;rsquo;s constructor is invoked when its concrete subclass is instantiated)&lt;/p&gt;

&lt;p&gt;b. no return type&lt;/p&gt;

&lt;p&gt;c. first statement must be super(); or this(); (if none was there, compiler insert super() call)&lt;/p&gt;

&lt;p&gt;d. if not type constructor, compiler generate a no-argu constructor automatically&lt;/p&gt;

&lt;p&gt;e. constructor name must match the class, and it&amp;rsquo;s legal to have method with same name as class name&lt;/p&gt;

&lt;p&gt;f. interface cannot have constructors, since they are not part of inheritance tree&lt;/p&gt;

&lt;p&gt;g. constructors are never inherited.(the type of constructor in super class can never determines the default constructor you get, and the default constructor is ALWAYS no-argu constructor)&lt;/p&gt;

&lt;p&gt;h. can overload constructor, and it&amp;rsquo;s used to provide alternate ways for clients to instaitate objects of your class. (p.s not always make sense, eg. java.awt.Color: you have to provide color info in constructor)&lt;/p&gt;

&lt;p&gt;i. constructor could have any access modifier, including private(only code with the class itself can instantiate an object of that type, if the private constructor class wants to allow an instance of the class to be used, the class must provide static method or variable that allow access to an instance created from within the class)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Static&lt;/p&gt;

&lt;p&gt;a. static = class; nonstatic = instance&lt;/p&gt;

&lt;p&gt;b. cannot access a nonstatic(instance) member(variables/methods) from static method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Animal {
   static void doStuff() {
       System.out.println(&amp;quot;a&amp;quot;);
      }
    }
  class Dog extends Animal {
 static void doStuff() {
     System.out.println(&amp;quot;d&amp;quot;);
     }  
   }
  public static void main(String[] args) {
     Animal[] a = {new Animal(), new Dog(), new Animal};
     for (int x = 0; x &amp;lt; a.length; x++) {
     a[x].doStuff(); // output: a a a
    }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Coupling v.s Cohesion&lt;/p&gt;

&lt;p&gt;a. Coupling: the degree to which one class knows about another class&lt;/p&gt;

&lt;p&gt;b. Cohesion: the degree to which a class has a single, well-defined row or reponsibility&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SCJP Reading Notes - 1</title>
      <link>http://sleephu.github.io/post/04-06-16/</link>
      <pubDate>Wed, 06 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sleephu.github.io/post/04-06-16/</guid>
      <description>&lt;p&gt;Summary
It is reading notes about the book &amp;ndash; SCJP.&lt;/p&gt;

&lt;p&gt;Declaration &amp;amp; Access Modifiers&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;default v.s protected&lt;/p&gt;

&lt;p&gt;default: package level access
 proceted: package + kids (subclass, access through inheritance, but not through a reference to an instance of the superclass)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;final abstract &amp;mdash;- wrong mix, opposite meaning&lt;/p&gt;

&lt;p&gt;final: cannot be subclassed;
 abstract: force to be subclassed&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reason to use final: security(satefy), java core libraries (String, Thread.isAlive)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;abstract v.s interface&lt;/p&gt;

&lt;p&gt;a. All methods in interface is implicitly public and abstract&lt;/p&gt;

&lt;p&gt;b. Interface can only define constants(public static final), not instance variables, while in abstract class, it could have instance variables&lt;/p&gt;

&lt;p&gt;c. An interface can extend one or more interfaces, abstract could only extend one other abstract class&lt;/p&gt;

&lt;p&gt;d. An interface can&amp;rsquo;t extend anything but another interface&lt;/p&gt;

&lt;p&gt;e. An interface can&amp;rsquo;t implement another interface/class&lt;/p&gt;

&lt;p&gt;f. An interface must be declared with the keyword interface, while it&amp;rsquo;s legal that not declare an abstract class with abstract keyword&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ldquo;this&amp;rdquo;: refers to currently executing object&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;final argument: keep the same value that the parameter had when it was passed into the method&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the first concrete class must implement all abstract methods of the super class&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;synchronized: only applies to method; a method can be accessed by only one thread at a time&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;static:&lt;/p&gt;

&lt;p&gt;a. exist independently of any instance created for the class&lt;/p&gt;

&lt;p&gt;b. static members exist before new instance of a class, and there will be only one copy of a static member regardless of the number of instances of that class&lt;/p&gt;

&lt;p&gt;c. all instances of a given class share the same value for any given static variable&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;constructor:&lt;/p&gt;

&lt;p&gt;a. same name as class name&lt;/p&gt;

&lt;p&gt;b. no return type&lt;/p&gt;

&lt;p&gt;c. cannot be static (since it is associated with object instantiation)&lt;/p&gt;

&lt;p&gt;d. cannot be final/abstract (since cannot be overriden)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;enum: a special kind of class, it can be used to restrict a variable to have one of only a few pre-defined values, which is good to reduce bugs.&lt;/p&gt;

&lt;p&gt;a. defined in different places(inside or outside a class), different ways to access it.&lt;/p&gt;

&lt;p&gt;b. like other class, could have constructor, instance variables, methods, etc.&lt;/p&gt;

&lt;p&gt;c. constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I. can never invoke enum constructors directly, and the constructor is invoked automatically with arguments you define after the constant value
II. can define more than one arguments to the constructor (can overload)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d. has static method: values(), returns array of the enum&amp;rsquo;s values&lt;/p&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; enum CoffeeSize {


   //4, 8, 10 are passed to the constructor
   SMALL(4), BIG(8), HUGE(10);
   CoffeeSize(int ounces) {
     this.ounces = ounces;
    }
    private int ounces;
    public int getOunces() {
       return ounces;
         } 
  } 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;p.s &amp;ldquo;final&amp;rdquo; is the only modifer could be used to local variables&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Airline On-time Performance Big Data Analytic System Development</title>
      <link>http://sleephu.github.io/project/airline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sleephu.github.io/project/airline/</guid>
      <description>&lt;p&gt;● A big data analytics platform was implemented with Hadoop and HBase (Deployed on Amazon AWS).&lt;/p&gt;

&lt;p&gt;● Analyzed Airline On-time performance data from 1987 to 2008 with hundred millions of records.&lt;/p&gt;

&lt;p&gt;● Set up development environment in EC2: Java Environment setup, Hadoop, HBase, Pig, Apache Phoenix, Hive, Spark, Tomcat installation and configuration.&lt;/p&gt;

&lt;p&gt;● Developed 10+ MapReduce jobs, several Pig UDF in Java and 10+ Pig scripts for data cleansing and preprocessing, and stored refined data to HBase.&lt;/p&gt;

&lt;p&gt;● Implemented logistic regression algorithm using Spark ML-Lib to predict airline delays.&lt;/p&gt;

&lt;p&gt;● Technologies used: Hadoop, HBase, Hive, Apache Phoenix, Pig were used at back-end. D3.js, morris.js, crossfilter.js, and Bootstrap framework were used at front-end.&lt;/p&gt;

&lt;p&gt;@Github: &lt;a href=&#34;https://github.com/sleephu/Airline-ontime-performance-Analytics-BigData&#34;&gt;https://github.com/sleephu/Airline-ontime-performance-Analytics-BigData&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amazone Same Day Delivery Application</title>
      <link>http://sleephu.github.io/project/amazon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sleephu.github.io/project/amazon/</guid>
      <description>&lt;p&gt;● A swing application was developed to provide a solution for same day product delivery on Netbeans in Java.&lt;/p&gt;

&lt;p&gt;● Followed the object oriented design principles and supported features including distributed virtual local suppliers, order processing, billing, invoicing, shipment and return management etc.&lt;/p&gt;

&lt;p&gt;● DB4O is used for data persistence.&lt;/p&gt;

&lt;p&gt;@Github &lt;a href=&#34;https://github.com/sleephu/A-Swing-project--Amazon-Same-Day-Delivery&#34;&gt;https://github.com/sleephu/A-Swing-project--Amazon-Same-Day-Delivery&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Climate Change Big Data Analytic System Development</title>
      <link>http://sleephu.github.io/project/climate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sleephu.github.io/project/climate/</guid>
      <description>&lt;p&gt;● A big data analytics platform was implemented with Spark and Cassandra (Deployed on Amazon AWS).&lt;/p&gt;

&lt;p&gt;● Analyzed GSOD Climate data from 1921 - 2013, (Raw data size around 21 GB).&lt;/p&gt;

&lt;p&gt;● Parsed data with Python and developed apps in Java for data cleansing and preprocessing, and loaded into Cassandra.&lt;/p&gt;

&lt;p&gt;● Implemented ARIMA algorithms with MATLAB ARIMA tool jar package to build prediction model for future climate.&lt;/p&gt;

&lt;p&gt;● Implemented k-means algorithms on Apache Spark cluster which provides real-time analytics capabilities to build clustering model to find areas with similar climate condition.&lt;/p&gt;

&lt;p&gt;● Built a responsive UI using Spring framework for interactive analysis.&lt;/p&gt;

&lt;p&gt;● Technologies used: Spark, Cassandra, Spring framework were used at back-end, Google Chart and Bootstrap framework were used at front-end.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>E-Commerce Web Platform for Restaurants</title>
      <link>http://sleephu.github.io/project/e-commerce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sleephu.github.io/project/e-commerce/</guid>
      <description>&lt;p&gt;● A C2C web application was developed for restaurants in Java in Eclipse.&lt;/p&gt;

&lt;p&gt;● The features include registration, login, restaurants search feature, menu viewing, order processing and reservation etc.&lt;/p&gt;

&lt;p&gt;● Designed and implemented data model in MySQL, and used hibernate as ORM for persistence.&lt;/p&gt;

&lt;p&gt;● Technologies used: Spring MVC framework, Hibernate, and Spring Security were used. jQuery, and Bootstrap framework were used on the client side&lt;/p&gt;

&lt;p&gt;@Github: &lt;a href=&#34;https://github.com/sleephu/spring-MVC-project&#34;&gt;https://github.com/sleephu/spring-MVC-project&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>